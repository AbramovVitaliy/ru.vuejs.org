---
title: Подробно о Реактивности
type: guide
order: 12
---

Мы разобрали большую часть основ — пришло время нырнуть поглубже! Одна из наиболее примечательных возможностей Vue — это ненавязчивая реактивность. Модели — это просто простые JavaScript-объекты. Когда вы изменяете их, представление данных обновляется. Управление состоянием приложения, таким образом, становится очень простым и интуитивно-понятным. Но для того чтобы избежать распространённых неприятностей, необходимо понимать, как это работает. В этой секции руководства мы немного покопаемся в низкоуровневых деталях реализации системы реактивности Vue.

## Как Отслеживаются Изменения

Когда вы передаёте в инстанс Vue простой JavaScript-объект в качестве опции `data`, Vue проходит по всем его полям и превращаит их в пары геттеров/сеттеров, используя [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty). Эта возможность имеется в JavaScript только начиная с версии ES5, и в более ранних версиях её сэмулировать не удаётся — по этой-то причине Vue и не поддерживает браузеры IE8 и старше.

Геттеры/сеттеры не видны пользователю, но именно они являются тем внутренним механизмом, что позволяет Vue отслеживать зависимости и детектировать изменение данных. Одним из недостатков этого подхода является то, что консоли браузера обычно форматируют геттеры/сеттеры отличным образом от обыкновенных объектов при их логировании, поэтому вам может пригодится [vue-devtools](https://github.com/vuejs/vue-devtools) с более удобным интерфейсом.

Каждый инстанс компонента имеет связанный с ним инстанс **наблюдателя**, который помечает все "затронутые" при рендеринге компонента поля как зависимости. В дальнейшем, когда вызывается сеттер помеченного как зависимость поля, он уведомляет наблюдателя, который в свою очередь инициирует перерендеринг компонента.

![Цикл Реактивности](/images/data.png)

## Проблемы с Определением Изменений

В силу ограничений современного JavaScript (и отказа от `Object.observe`), Vue **не может определить добавление или удаление свойства**. Поскольку Vue производит превращение полев в пары геттер/сеттер в процессе инициализации инстанса, все поля должны присутствовать в объекте `data` изначально, чтобы быть сконвертированы и стать реактивными. Например:

``` js
var vm = new Vue({
  data: {
    a: 1
  }
})
// `vm.a` теперь — реактивное поле

vm.b = 2
// `vm.b` НЕ реактивно
```

Vue не позволяет динамическое добавление новых корневых реактивных свойств в уже существующий инстанс. Однако, возможно добавление реактивных свойств во вложенные объекты, используя метод `Vue.set(object, key, value)`:

``` js
Vue.set(vm.someObject, 'b', 2)
```

Вы можете также использовать метод инстанса `vm.$set`, который является просто псевдонимом к глобальному `Value.set`:

``` js
this.$set(this.someObject, 'b', 2)
```

Иногда вы можете захотеть добавить несколько свойств в существующий объект, например используя `Object.assign()` или `_.extend()`. Однако, новые свойства, добавленные к объекту, не вызовут реактивной обработки изменений. В таких случаях, создавайте новый объект, содержащий поля как оригинального объекта, так и объекта-примеси:

``` js
// вместо `Object.assign(this.someObject, { a: 1, b: 2 })`
this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
```

Существует также несколько ограничений, связанных с массивами. Их мы рассмотрели ранее в [секции об отображении списков](list.html#Caveats).

## Объявление реактивных свойств

Поскольку Vue не позволяет динамически добавлять корневые реактивные свойства, это означает что все корневые поля необходимо инициализировать изначально, хотя бы пустыми значениями:

``` js
var vm = new Vue({
  data: {
    // объявляем поле message со значением пустой строки
    message: ''
  },
  template: '<div>{{ message }}</div>'
})
// впоследствии задаём значение `message`
vm.message = 'Hello!'
```

Если поле `message` в опции data не указать, Vue предупредит вас что функция рендеринга пытается получить доступ к несуществующему свойству.

Есть технические причины для этого ограничения — оно позволяет устранить целый класс краевых случаев в системе учёта зависимостей, а так же позволяет Vue лучше взаимодействовать с системами проверки типов. Но кроме того существует ещё и важный момент с точки зрения поддерживаемости кода: объект `data` похож на схему для состояния вашего компонента. Явное объявление всех реактивных свойств делает код компонента проще для понимания при последующем прочтении, или для стороннего разработчика.

## Асинхронная Очередь Обновлений

На случай если вы ещё не заметили: Vue выполняет обновления DOM **асинхронно**. Каждый раз, когда обнаруживается изменение в данных, создаётся очередь, в которую буферизируются все остальные изменения, происходящие в том же самом event loop. Если тот же наблюдатель вызывается несколько раз, в очередь он попадёт всё равно лишь единожды. Эта буферизация и де-дупликация важны, так как позволяют избежать излишних вычислений и манипуляций с DOM. Затем, по следующему "тику" event loop'а, Vue разбирает очередь и выполняет актуальную (уже не содержащую дубликатов) работу. Внутренние детали реализации этого процесса таковы: Vue пробует применить нативные `Promise.then` и `MutationObserver` для асинхронной постановки задач во очередь, а в случае их недоступности использует старую добрую `setTimeout(fn, 0)`.

Например, когда вы обновляете `vm.someData = 'new value'`, компонент не будет перерендерен сразу же. Он обновится на следующий "тик", при разборе очереди. Чаще всего у нас нет нужды принимать это в расчёт, но не если вы хотите сделать что-то, зависящее от состояния DOM после обновления. Хотя Vue в целом поощряет мышление "от данных" и не рекомендует напрямую трогать DOM, иногда приходится засучить рукава. Для того чтобы дождаться завершения обновления DOM после изменения данных, вы можете использовать `Vue.nextTick(callback)` сразу после того, как данные изменены. Функция обратного вызова будет вызвана после обновления DOM. Например:

``` html
<div id="example">{{ message }}</div>
```

``` js
var vm = new Vue({
  el: '#example',
  data: {
    message: '123'
  }
})
vm.message = 'новое сообщение' // изменяем данные
vm.$el.textContent === 'новое сообщение' // false
Vue.nextTick(function () {
  vm.$el.textContent === 'новое сообщение' // true
})
```

Существует также метод инстанса `vm.$nextTick()`, особенно удобный для использования внутри компонент, поскольку он не требует обращения к глобальной переменной `Vue`, а также автоматически связывает контекст `this` функции обратного вызова с текущим инстансом Vue:

``` js
Vue.component('example', {
  template: '<span>{{ message }}</span>',
  data: function () {
    return {
      message: 'не обновлено'
    }
  },
  methods: {
    updateMessage: function () {
      this.message = 'обновлено'
      console.log(this.$el.textContent) // => 'не обновлено'
      this.$nextTick(function () {
        console.log(this.$el.textContent) // => 'обновлено'
      })
    }
  }
})
```
