---
type: api
---

## Глобальный Конфиг

`Vue.config` - это объект, содержащий глобальную конфигурацию Vue. Вы можете изменить его нижеперечисленные свойства перед начальной загрузкой вашего приложения:

### silent

- **Тип:** `boolean`

- **По умолчанию:** `false`

- **Использование:**

  ``` js
  Vue.config.silent = true
  ```

  Подавляет все логи и предупреждения Vue.

### optionMergeStrategies

- **Тип:** `{ [key: string]: Function }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {
    return child + 1
  }

  const Profile = Vue.extend({
    _my_option: 1
  })

  // Profile.options._my_option = 2
  ```

  Определяет пользовательские стратегии слияния для опций.

  Стратегия слияния получает значения опции, определённые в родительском и дочернем элементах как первый и второй параметр соответственно. Контекст действующего инстанса Vue передаётся как третий аргумент.

- **См. также:** [Пользовательские Методы Слияния Опций](/guide/mixins.html#Custom-Option-Merge-Strategies)

### devtools

- **Тип:** `boolean`

- **По умолчанию:** `true` (`false` в production-сборках)

- **Использование:**

  ``` js
  // удостоверьтесь, что эта опция устанавливается синхронно сразу после загрузки Vue
  Vue.config.devtools = true
  ```

  Указывает, позволять ли инспекции [vue-devtools](https://github.com/vuejs/vue-devtools). Значение по умолчанию для development-окружения — `true`, для production-сборок — `false`. Вы можете установить `true` для использования vue-devtools в production-окружении.

### errorHandler

- **Тип:** `Function`

- **По умолчанию:** Ошибка выбрасывается "на месте"

- **Использование:**

  ``` js
  Vue.config.errorHandler = function (err, vm) {
    // обработка ошибки
  }
  ```

  Устанавливает обработчик для ошибок, не пойманных во время рендеренга компонент и в наблюдателях. Обработчик при вызове будут передана ошибка и действующий инстанс Vue.

  > [Sentry](https://sentry.io), сервис трекинга ошибок, предоставляет [официальную интеграцию](https://sentry.io/for/vue/), с использованием этой опции.

### keyCodes

- **Тип:** `{ [key: string]: number }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.keyCodes = {
    v: 86,
    f1: 112,
    mediaPlayPause: 179
  }
  ```

  Определяет пользовательский алиас(ы) для директивы v-on.

## Глобальное API

<h3 id="Vue-extend">Vue.extend( options )</h3>

- **Аргументы:**
  - `{Object} options`

- **Использование:**

  Создаёт "подкласс" базового конструктора Vue. Параметром должен быть объект, содержащий опции компонента.  

  Внимание: при использовании с `Vue.extend()` опция `data` должна быть определена как функция.  

  ``` html
  <div id="mount-point"></div>
  ```

  ``` js
  // create constructor
  var Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
    data: function () {
      return {
        firstName: 'Walter',
        lastName: 'White',
        alias: 'Heisenberg'
      }
    }
  })
  // создаёт инстанс Profile и монтирует его к элементу DOM
  new Profile().$mount('#mount-point')
  ```

  Результатом будет:

  ``` html
  <p>Walter White aka Heisenberg</p>
  ```

- **См. также:** [Компоненты](/guide/components.html)

<h3 id="Vue-nextTick">Vue.nextTick( callback, [context] )</h3>

- **Аргументы:**
  - `{Function} callback`
  - `{Object} [context]`

- **Использование:**

  Откладывает выполнение callback-функции до следующего цикла обновления DOM. Используйте непосредственно после того как изменяете какие-либо данные чтобы подождать обновления DOM.
  

  ``` js
  // modify data
  vm.msg = 'Hello'
  // DOM ещё не обновлён
  Vue.nextTick(function () {
    // теперь DOM обновлён
  })
  ```

- **См. также:** [Очередь Асинхронных Обновлений](/guide/reactivity.html#Async-Update-Queue)

<h3 id="Vue-set">Vue.set( object, key, value )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`
  - `{any} value`

- **Returns:** установленное значение.

- **Использование:**

  Устанавливает значение поля объекта. Если объект является реактивным, удостоверится что поле будет создано как реактивное и запустит обновления view. Главным образом используется для обхода ограничения, из-за которого Vue не может детектировать добавление полей неявно.

  **Обратите внимание что объект не может быть инстансом Vue или корневым объектом data инстанса Vue.**

- **См. также:** [Подробно о Реактивности](/guide/reactivity.html)

<h3 id="Vue-delete">Vue.delete( object, key )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`

- **Использование:**

  Удаляет поле объекта. Если объект является реактивным, удостоверится что удаление запустит обновления view. Главным образом используется для обхода ограничения, из-за которого Vue не может детектировать удаления полей неявно, хотя вам в ряд ли часто понадобится использовать эту возможность.

  **Обратите внимание что объект не может быть инстансом Vue или корневым объектом data инстанса Vue.**

- **См. также:** [Подробно о Реактивности](/guide/reactivity.html)

<h3 id="Vue-directive">Vue.directive( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует или получает глобальную директиву.  

  ``` js
  // регистрация
  Vue.directive('my-directive', {
    bind: function () {},
    inserted: function () {},
    update: function () {},
    componentUpdated: function () {},
    unbind: function () {}
  })

  // регистрация (директива в виде простой функции)
  Vue.directive('my-directive', function () {
    // эта функция будет вызвана как `bind` и `update`
  })

  // геттер, вернёт определение директивы, если она зарегистрирована  
  var myDirective = Vue.directive('my-directive')
  ```

- **См. также:** [Пользовательские Директивы](/guide/custom-directive.html)

<h3 id="Vue-filter">Vue.filter( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function} [definition]`

- **Использование:**

  Регистрирует или получает глобальный фильтр.

  ``` js
  // регистрация
  Vue.filter('my-filter', function (value) {
    // return processed value
  })

  // геттер, вернёт фильтр если он зарегистрирован
  var myFilter = Vue.filter('my-filter')
  ```

<h3 id="Vue-component">Vue.component( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует или получает глобальный компонент

  ``` js
  // регистрирует расширенный конструктор
  Vue.component('my-component', Vue.extend({ /* ... */ }))

  // регистрирует объект опций (Vue.extend будет вызвана автоматически)
  Vue.component('my-component', { /* ... */ })

  // получает зарегистрированный компонент (всегда вернёт конструктор)
  var MyComponent = Vue.component('my-component')
  ```

- **См. также:** [Компоненты](/guide/components.html)

<h3 id="Vue-use">Vue.use( plugin )</h3>

- **Аргументы:**
  - `{Object | Function} plugin`

- **Использование:**

  Устанавливает плагин Vue.js. Если плагин определён как объект, он должен содержать публичный метод `install`. Если плагин сам является функцией, он будет воспринят как метод install. Упомянутый метод будет вызван с Vue в качестве аргумента.

  При многократном вызове этого метода с одним и тем же плагином, плагин будет установлен только однажды.  

- **См. также:** [Плагины](/guide/plugins.html)

<h3 id="Vue-mixin">Vue.mixin( mixin )</h3>

- **Аргументы:**
  - `{Object} mixin`

- **Использование:**

  Применяет миксин глобально, оказывая влияние на все созданные впоследствии инстансы Vue. Это может быть использовано авторами плагинов для инъекции пользовательского поведения в компоненты. **Не рекомендуется к использованию в коде приложений**.  

- **См. также:** [Глобальные Миксины](/guide/mixins.html#Global-Mixin)

<h3 id="Vue-compile">Vue.compile( template )</h3>

- **Аргументы:**
  - `{string} template`

- **Использование:**

  Компилирует строковой шаблон в render-функцию. **Доступно только в автономной сборке.**

  ``` js
  var res = Vue.compile('<div><span>{{ msg }}</span></div>')

  new Vue({
    data: {
      msg: 'hello'
    },
    render: res.render,
    staticRenderFns: res.staticRenderFns
  })
  ```

- **См. также:** [Render-Функции](/guide/render-function.html)

## Опции / Data

### data

- **Тип:** `Object | Function`

- **Ограничение:** Принимает только `Function` когда используется при определении компонентов.

- **Подробности:**

  Объект данных для инстанса Vue. Vue рекурсивно конвертирует поля этого объекта в геттеры/сеттеры чтобы сделать его "реактивным". **Объект должен быть простым**: нативные объекты, такие как объекты API браузера и свойства прототипа игнорируются. Упрощённо, правило состоит в том чтобы данные были просто данными — наблюдение за обладающими собственным зависящим от состояния поведением не рекомендуется.
  
  Однажды начав наблюдение, вы не сможете больше добавлять реактивные свойства к корневому объекту данных. По этой причине рекоммендуется определять все реактивные свойства корневого уровня заранее, до создания инстанса.

  После того как инстанс был создан, доступ к оригиналу объекта данных может быть получен как `vm.$data`. инстанс Vue также проксирует все свойства, обнаруженные в объекте data, так что `vm.a` будет эквивалентно `vm.$data.a`.

  Свойства, названия которых начинается с `_` или `$` **не** проксируются из-за возможных конфликтов со внутренними свойствами и методами API Vue. Доступ к таким свойствам возможен только через `vm.$data._property`.  

  При определении **компонента**, `data` должна быть определена как функция, возвращающая объект для инициализации, так как будет создано множество инстансов компонента, используя одно и то же определение. Если бы мы всё так же использовали для `data` простой объект, **ссылку на него** получили бы все созданные инстансы! При использовании функции для `data`, при каждом создании нового инстанса мы можем попросту вызвать эту функцию и вернуть свежую копию данных для инициализации.
  
  При необходимости полная копия оригинального объекта может быть получена при передаче `vm.$data` как аргумента в `JSON.parse(JSON.stringify(...))`.

- **Пример:**

  ``` js
  var data = { a: 1 }

  // прямое создание инстанса
  var vm = new Vue({
    data: data
  })
  vm.a // -> 1
  vm.$data === data // -> true

  // при использовании Vue.extend() необходимо использование функции
  var Component = Vue.extend({
    data: function () {
      return { a: 1 }
    }
  })
  ```

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции в параметре `data`__ (напр. `data: () => { return { a: this.myProp }}`). Причина в том, что arrow-функции связываются с родительским контекстом, и таким образом `this` не будет указывать на инстанс Vue (что ожидается), и `this.myProp` окажется неопределенным.</p>

- **См. также:** [Подробно о Реактивности](/guide/reactivity.html)

### props

- **Тип:** `Array<string> | Object`

- **Подробности:**

  Список или хэш аттрибутов, по которым разрешено получение данных от родительского компонента. Допустима простая форма записи на основе массивов и альтертанивный объектный синтаксис, позволяющий расширенное конфигурирование, такое как проверка типов, пользовательская валидация и указание значений по умолчанию.

- **Пример:**

  ``` js
  // простая форма записи
  Vue.component('props-demo-simple', {
    props: ['size', 'myMessage']
  })

  // объектный синтаксис, с указанием правил валидации
  Vue.component('props-demo-advanced', {
    props: {
      // только проверка типа
      height: Number,
      // проверка типа плюс другие правила валидации
      age: {
        type: Number,
        default: 0,
        required: true,
        validator: function (value) {
          return value >= 0
        }
      }
    }
  })
  ```

- **См. также:** [Параметры Компонентов](/guide/components.html#Props)

### propsData

- **Тип:** `{ [key: string]: any }`

- **Ограничение:** учитывается только при создании инстанса через `new`.

- **Подробности:**

  Передаёт параметры компоненту при его создании. В основном предназначено для облегчения тестирования.

- **Пример:**

  ``` js
  var Comp = Vue.extend({
    props: ['msg'],
    template: '<div>{{ msg }}</div>'
  })

  var vm = new Comp({
    propsData: {
      msg: 'hello'
    }
  })
  ```

### computed

- **Тип:** `{ [key: string]: Function | { get: Function, set: Function } }`

- **Подробности:**

  Содержит вычисляемые свойства, которые будут подмешаны к инстансу Vue. Контекст `this` всех геттеров и сеттеров привязывается к инстансу Vue автоматически.

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции при определении вычисляемых свойств__ (напр. `aDouble: () => this.a * 2`). Причина в том, что arrow-функции связываются с родительским контекстом, и таким образом `this` не будет указывать на инстанс Vue (что ожидается), и `this.a` окажется неопределенным.</p>

  Вычисляемые свойства кэшируются и повторно вычисляются только при изменении реактивных зависимостей.

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    computed: {
      // только получение данных, достаточно простой функции
      aDouble: function () {
        return this.a * 2
      },
      // и получение и установка
      aPlus: {
        get: function () {
          return this.a + 1
        },
        set: function (v) {
          this.a = v - 1
        }
      }
    }
  })
  vm.aPlus   // -> 2
  vm.aPlus = 3
  vm.a       // -> 2
  vm.aDouble // -> 4
  ```

- **См. также:**
  - [Вычисляемые Свойства](/guide/computed.html)

### methods

- **Тип:** `{ [key: string]: Function }`

- **Подробности:**

  Методы, которые будут подмешаны к инстансу Vue. Вы можете получить доступ к этим методам непосредственно через инстанс VM, или использовать их в выражениях директив. Контекст `this` всех методов привязывается к инстансу Vue автоматически.

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции при определении методов__ (напр. `plus: () => this.a++`). Причина в том, что arrow-функции связываются с родительским контекстом, и таким образом `this` не будет указывать на инстанс Vue (что ожидается), и `this.a` окажется неопределенным.</p>

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    methods: {
      plus: function () {
        this.a++
      }
    }
  })
  vm.plus()
  vm.a // 2
  ```

- **См. также:** [Методы и Обработка Событий](/guide/events.html)

### watch

- **Тип:** `{ [key: string]: string | Function | Object }`

- **Подробности:**

  Объект, ключи которого — выражения для наблюдения, а значения — соответствующие функции обратного вызова. Значения также могут строками с именами методов, или объектами, содержащими дополнительные опции. инстанс Vue вызовет `$watch()` для каждой записи при создании инстанса.

- **Пример:**

  ``` js
  var vm = new Vue({
    data: {
      a: 1,
      b: 2,
      c: 3
    },
    watch: {
      a: function (val, oldVal) {
        console.log('new: %s, old: %s', val, oldVal)
      },
      // строка с именем метода
      b: 'someMethod',
      // глубокий наблюдатель
      c: {
        handler: function (val, oldVal) { /* ... */ },
        deep: true
      }
    }
  })
  vm.a = 2 // -> new: 2, old: 1
  ```

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции при определении наблюдателей__ (напр. `searchQuery: newValue => this.updateAutocomplete(newValue)`). Причина в том, что arrow-функции связываются с родительским контекстом, и таким образом `this` не будет указывать на инстанс Vue (что ожидается), и `this.updateAutocomplete` окажется неопределенным.</p>

- **См. также:** [Instance Methods - vm.$watch](#vm-watch)

## Опции / DOM

### el

- **Тип:** `string | HTMLElement`

- **Ограничение:** используется только при создании инстанса через `new`.

- **Подробности:**

  Указывает, на какой существующий элемент DOM будет смонтирован инстанс Vue. Может быть строковым CSS-селектором или собственно инстансом HTMLElement.

  После монтирования инстанса, разрешённый элемент будет доступен как `vm.$el`.

  Если эта опция указана при создании инстанса, компиляция будет начата незамедлительно. В противном случае для ручного старта компиляции будет необходимо явно вызвать `vm.$mount()`.

  <p class="tip">Указанный элемент служит исключительно точкой монтирования. В отличии от Vue 1.x, он будет заменен сгенерированным Vue DOM во всех случаях. По этой причине монтирование в корневые элементы `<html>` или `<body>` не рекоммендуется.</p>

- **См. также:** [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)

### template

- **Тип:** `string`

- **Подробности:**

  Строковый шаблон, который будет использован как разметка для инстанса Vue. Этот шаблон **заменит** элемент в точке монтирования. Вся уже существующая разметка внутри точки монтирования будет проигнорирована, за исключением случаев наличия слотов дистрибьюции контента в шаблоне.

  Если строка начинается с `#`, она будет использована как querySelector, а в качестве строкового шаблона будет использован innerHTML элемента с указанным id. Это позволяет использовать распространённый трюк с `<script type="x-template">` для включения шаблонов.

  <p class="tip">С позиций безопасности, вы должны всегда использовать только те шаблоны Vue, которым можете доверять. Никогда не используйте в качестве шаблона данные, вводимые пользователем.</p>

- **См. также:**
  - [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)
  - [Дистрибьюция Контента посредством Слотов](/guide/components.html#Content-Distribution-with-Slots)

### render

  - **Тип:** `Function`

  - **Подробности:**

    Альтернатива строковым шаблонам, позволяющая задействовать все алгоритмические возможности JavaScript. Render-функция получает первым аргументом метод `createElement`, используемый для создания `VNode`-ов.

    Если компонент является функциональным, также передаётся второй параметр `context`, дающий доступ к контекстным данным, так как функциональные компоненты не имеют инстансов.

  - **См. также:**
    - [Render-Функции](/guide/render-function)

## Опции / Хуки Жизненного Цикла

Контекст `this` всех хуков автоматически привязывается к инстансу, что даёт доступ к данным, вычисляемым свойствам и методам. Это значит, что __вам не следует использовать arrow-функции для определения методов жизненного цикла__ (напр. `created: () => this.fetchTodos()`). Причина в том, что arrow-функции связываются с родительским контекстом, и таким образом `this` не будет указывать на инстанс Vue (что ожидается), и `this.fetchTodos` окажется неопределенным.

### beforeCreate

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после инициализации инстанса, до настройки наблюдения за данными и механизмов наблюдателей/событий.

- **См. также:** [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)

### created

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после создания инстанса. На этом этапе инстанс закончил обработку опций, что означает что все нижеперечисленное уже работает: наблюдение за данными, вычисляемые свойства, методы, функции обратного вызова наблюдателей и событий. Однако, фаза монтирования ещё не была начата, и свойство `$el` ещё не будет доступно.

- **См. также:** [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)

### beforeMount

- **Тип:** `Function`

- **Подробности:**

  Вызывается перед началом монтирования: сразу перед первым вызовом функции `render`.  

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)

### mounted

- **Тип:** `Function`

- **Подробности:**

  Вызывается сразу после того как инстанс был смонтирован, а `el` — заменено новосозданным `vm.$el`. Если корневой инстанс смонтирован на in-document элемент, `vm.$el` будет также in-document элементом к моменту вызова `mounted`.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)

### beforeUpdate

- **Тип:** `Function`

- **Подробности:**

  Вызывается при изменении данных, перед ререндерингом и обновлением virtual DOM.

  В этом хуке можно дополнительно изменять состояние, и это не вызовет повторного ререндеринга.  

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)

### updated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после того как virtual DOM был обновлён вследствие изменения данных.

  DOM компонента будет находиться в обновлённом состоянии к моменту вызова этого хука, что позволяет выполнять здесь операции, имеющие зависимость от DOM. Однако, в большинстве случаев следует избегать изменения состояния в этом хуке, поскольку это может привести к бесконечному циклу обновления.  

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)

### activated

- **Тип:** `Function`

- **Подробности:**

  Вызывается при активации keep-alive компонента.  

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:**
  - [Built-in Компоненты - keep-alive](#keep-alive)
  - [Динамические Компоненты - keep-alive](/guide/components.html#keep-alive)

### deactivated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после деактивации keep-alive компонента.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:**
  - [Built-in Компоненты - keep-alive](#keep-alive)
  - [Динамические Компоненты - keep-alive](/guide/components.html#keep-alive)

### beforeDestroy

- **Тип:** `Function`

- **Подробности:**

  Вызывается непосредственно перед уничтожением инстанса Vue. На этом этапе инстанс всё ещё полностью функционален.  

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)

### destroyed

- **Тип:** `Function`

- **Подробности:**

  Вызывается после уничтожения инстанса Vue. К моменту вызова этого хука, все директивы инстанса Vue уже отвязаны, все слушатели событий — удалены, все дочерние инстансы Vue — также уничтожены.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)

## Опции / Assets

### directives

- **Тип:** `Object`

- **Подробности:**

  Хэш директив которые будут доступны инстансу Vue.

- **См. также:**
  - [Пользовательские Директивы](/guide/custom-directive.html)
  - [Соглашение по Именованию Asset'ов](/guide/components.html#Assets-Naming-Convention)

### filters

- **Тип:** `Object`

- **Подробности:**

  Хэш фильтров которые будут доступны инстансу Vue.

- **См. также:**
  - [`Vue.filter`](#Vue-filter)

### components

- **Тип:** `Object`

- **Подробности:**

  Хэш компонентов которые будут доступны инстансу Vue.

- **См. также:**
  - [Компоненты](/guide/components.html)

## Options / Разное

### parent

- **Тип:** `Vue instance`

- **Подробности:**

  Указывает родительский инстанс для создаваемого. Устанавливает отношение "родитель-ребёнок" между ними. Родительский элемент будет доступен для дочернего через `this.$parent`, а дочерний элемент будет дабавлен в массив `$children` родителя.  

  <p class="tip">Use `$parent` and `$children` sparringly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</p>

### mixins

- **Тип:** `Array<Object>`

- **Подробности:**

  Опция `mixins` принимает массив объектов-примесей. Примеси могут содержать точно такие же опции, как и обычные объекты инстансов Vue, и они будут слиты с основными опциями по той же логике, что и при использовании `Vue.extend()`. Например, если и примесь и объект оба содержат хук `created`, вызваны будут обе функции.

  Хуки примесей вызываются в порядке их определения, перед вызовом собственных хуков компонента.

- **Пример:**

  ``` js
  var mixin = {
    created: function () { console.log(1) }
  }
  var vm = new Vue({
    created: function () { console.log(2) },
    mixins: [mixin]
  })
  // -> 1
  // -> 2
  ```

- **См. также:** [Mixins](/guide/mixins.html)

### name

- **Тип:** `string`

- **Ограничение:** учитывается только при определении компонента.

- **Подробности:**

  Позволяет компоненту рекурсивно вызывать самого себя в шаблоне. Обратите внимание что когда компонент регистрируется глобально посредством `Vue.component()`, глобальный ID автоматически устанавливается равным его имени.
  
  Другое преимущество указания опции `name` проявляется в отладке. Именованние компонент приводит к более понятным предупреждающим сообщениям. Также, при использовании [vue-devtools](https://github.com/vuejs/vue-devtools) безымянные компоненты отображаются как `<AnonymousComponent>`, что не очень информативно. Указывая опцию `name`, вы получите значительно более информативное дерево компонент.

### extends

- **Тип:** `Object | Function`

- **Подробности:**

  Позволяет декларативно наследоваться от другого компонента (может быть либо простым объектом, либо конструктором), не используя `Vue.extend`. Главным образом предназначено для облегчения наследования между компонентами, хранимыми в единых файлах.

  Эта функциональность близка к `mixins`, с разницей в том, что собственные опции компонента имеют высший приоритет над опциями компонента, от которого происходит наследование.

- **Пример:**

  ``` js
  var CompA = { ... }

  // наследование от CompA без необходимость вызывать Vue.extend ни в том ни в другом
  var CompB = {
    extends: CompA,
    ...
  }
  ```

### delimiters

- **Тип:** `Array<string>`

- **По умолчанию:** `["{{", "}}"]`

- **Подробности:**

  Изменяет маркеры, выделяющие текст для интерполяции. **Доступно только в автономной сборке.**

- **Пример:**

  ``` js
  new Vue({
    delimiters: ['${', '}']
  })

  // Маркеры в шаблонах изменены на стиль ES6
  ```

### functional

- **Тип:** `boolean`

- **Подробности:**

  Превращает компонент в stateless (не имеющий `data`) и instanceless (без контекста `this`). Такие компоненты представляют собой попросту функцию `render`, которая возвращает узлы Virtual DOM, делая рендеринг значительно дешевле.  

- **См. также:** [Функциональные Компоненты](/guide/render-function.html#Functional-Components)

## Instance Properties

### vm.$data

- **Тип:** `Object`

- **Подробности:**

  Объект данных, над которым инстанс Vue осуществляет наблюдение. инстанс проксирует доступ к объекту данных через это поле.  

- **См. также:** [Опции - data](#data)

### vm.$el

- **Тип:** `HTMLElement`

- **Только для чтения**

- **Подробности:**

  Корневой элемент DOM, управляемый инстансом Vue.

### vm.$options

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Опции инстанциирования, использованные для текущего инстанса Vue. Полезно, когда вы хотите включить пользовательские свойства в опции:  

  ``` js
  new Vue({
    customOption: 'foo',
    created: function () {
      console.log(this.$options.customOption) // -> 'foo'
    }
  })
  ```

### vm.$parent

- **Тип:** `Vue instance`

- **Только для чтения**

- **Подробности:**

  Родительский инстанс, если присутствует.

### vm.$root

- **Тип:** `Vue instance`

- **Только для чтения**

- **Подробности:**

  Корневой инстанс Vue текущего дерева компонентов. Если текущий инстанс не имеет родителей, значением будет он сам.

### vm.$children

- **Тип:** `Array<Vue instance>`

- **Только для чтения**

- **Подробности:**

  Компоненты, являющиеся прямыми потомками текущего инстанса. **Обратите внимания, что порядок следования элементов в `$children` не гарантируется, и этот массив не реактивен.** Если вы обнаружите, что пытаетесь использовать `$children` для связывания данных, попробуйте использовать массив и директиву `v-for` для создания дочерних компонент, и используйте этот массив как "источник истины".

### vm.$slots

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Используется для доступа к контенту, [распространяемому через слоты](/guide/components.html#Content-Distribution-with-Slots). Каждый [именованный слот](/guide/components.html#Named-Slots) имеет собственное соответствующее значение (например, содержимое `slot="foo"` будет находится в `vm.$slots.foo`). Свойство `default` содержит узлы, не включённые в именованные слоты.
  
  Использование `vm.$slots` более всего находит своё применение при написании компонентов с [render-функциями](/guide/render-function.html).

- **Пример:**

  ```html
  <blog-post>
    <h1 slot="header">
      About Me
    </h1>

    <p>Этот контент будет включён в vm.$slots.default, поскольку не находится внутри именованного слота.</p>

    <p slot="footer">
      Copyright 2016 Evan You
    </p>

    <p>Этот контент также будет включён в vm.$slots.default.</p>.
  </blog-post>
  ```

  ```js
  Vue.component('blog-post', {
    render: function (createElement) {
      var header = this.$slots.header
      var body   = this.$slots.default
      var footer = this.$slots.footer
      return createElement('div', [
        createElement('header', header)
        createElement('main', body)
        createElement('footer', footer)
      ])
    }
  })
  ```

- **См. также:**
  - [`<slot>` Component](#slot)
  - [Дистрибьюция Контента посредством Слотов](/guide/components.html#Content-Distribution-with-Slots)
  - [Render-Функции](/guide/render-function.html)

### vm.$refs

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Объект, содержащий дочерние компоненты, зарегистрировавшие параметр `ref`.

- **См. также:**
  - [Ссылки Дочерних Компонентов](/guide/components.html#Child-Component-Refs)
  - [ref](#ref)

### vm.$isServer

- **Тип:** `boolean`

- **Только для чтения**

- **Подробности:**

  Запущен ли данный инстанс Vue на сервере.

- **См. также:** [Рендеринг на Сервере](/guide/ssr.html)

## Методы инстанса / Данные

<h3 id="vm-watch">vm.$watch( expOrFn, callback, [options] )</h3>

- **Аргументы:**
  - `{string | Function} expOrFn`
  - `{Function} callback`
  - `{Object} [options]`
    - `{boolean} deep`
    - `{boolean} immediate`

- **Returns:** `{Function} unwatch`

- **Использование:**

  Осуществляет наблюдение за выражением или вычисляемой функцией инстанса Vue на предмет изменений. Функция обратного вызывается с новым и старым значениями наблюдаемого объекта в качестве параметров. Выражение может быть как одиночным путём до переменной, так и любым валидным для связывания выражением. //TODO

<p class="tip">Обратите внимание: при изменении (мутации, не замене) объекта (Object) или массива (Array), старое и новое значения будут совпадать, так как они ссылаются на один и тот же Object/Array. Vue не сохраняяет копии объекта на момент, предшествовавший изменениям.</p>  

- **Пример:**

  ``` js
  // путь до переменной
  vm.$watch('a.b.c', function (newVal, oldVal) {
    // что-нибудь происходит
  })

  // выражение
  vm.$watch('a + b', function (newVal, oldVal) {
    // что-нибудь происходит
  })

  // функция
  vm.$watch(
    function () {
      return this.a + this.b
    },
    function (newVal, oldVal) {
      // что-нибудь происходит
    }
  )
  ```

  `vm.$watch` возвращает функцию unwatch, которая останавливает дальнейшее наблюдение:

  ``` js
  var unwatch = vm.$watch('a', cb)
  // позднее, выключение наблюдения
  unwatch()
  ```

- **Опция: deep**

  Чтобы детектировать также и изменения во вложенных объектах, необходимо передать `deep: true` в параметре options. Обратите внимания, что для наблюдения за изменениями массивов этого не требуется.

  ``` js
  vm.$watch('someObject', callback, {
    deep: true
  })
  vm.someObject.nestedValue = 123
  // вызывается callback
  ```

- **Опция: immediate**

  Указание `immediate: true` в опциях повлечёт немедленный вызов функции обратноо вызова с текущим значением выражения:

  ``` js
  vm.$watch('a', callback, {
    immediate: true
  })
  // callback вызывается сразу, с текущим значением `a`
  ```

<h3 id="vm-set">vm.$set( object, key, value )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`
  - `{any} value`

- **Returns:** установленное значение.

- **Использование:**

  Это — **алиас** глобального метода `Vue.set`.

- **См. также:** [Vue.set](#Vue-set)

<h3 id="vm-delete">vm.$delete( object, key )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`

- **Использование:**

  Это — **алиас** глобального метода `Vue.delete`.

- **См. также:** [Vue.delete](#Vue-delete)

## Методы инстанса / События

<h3 id="vm-on">vm.$on( event, callback )</h3>

- **Аргументы:**
  - `{string} event`
  - `{Function} callback`

- **Использование:**

  Слушает пользовательское событие в текущем vm. События могут быть порождены с помощью `vm.$emit`. Функция обратного вызова получит все дополнительные аргументы, переданные эти порождающие методы.
 
- **Пример:**

  ``` js
  vm.$on('test', function (msg) {
    console.log(msg)
  })
  vm.$emit('test', 'hi')
  // -> "hi"
  ```

<h3 id="vm-once">vm.$once( event, callback )</h3>

- **Аргументы:**
  - `{string} event`
  - `{Function} callback`

- **Использование:**

  Слушает пользовательское событие, но лишь однократно. После первого использования слушатель будет удалён.

<h3 id="vm-off">vm.$off( [event, callback] )</h3>

- **Аргументы:**
  - `{string} [event]`
  - `{Function} [callback]`

- **Использование:**

  Удаляет слушателя(-ей).

  - Если вызвано без параметров, удалит все слушатели;

  - Если указан только тип события, удалит все слушатели этого события;

  - Если указан и тип события, и функция обратного вызова, слушатель будет удалён только для этой конкретной функции.

<h3 id="vm-emit">vm.$emit( event, [...args] )</h3>

- **Аргументы:**
  - `{string} event`
  - `[...args]`

  Инициирует событие в текущем инстансе. Все дополнительно указанные параметры будут переданы в функцию обратного вызова слушателя.

## Instance Methods / Lifecycle

<h3 id="vm-mount">vm.$mount( [elementOrSelector] )</h3>

- **Аргументы:**
  - `{Element | string} [elementOrSelector]`
  - `{boolean} [hydrating]`

- **Returns:** `vm` - сам инстанс

- **Использование:**

  Если при создании инстанса Vue не была указана опция `el`, он будет находится в "несмонтированном" ("unmounted") состоянии, без ассоциированного элемента DOM. `vm.$mount()` может быть использовано, чтобы вручную примонтировать несмонтированный инстанс Vue.

  Если параметр `elementOrSelector` не указан, шаблон будет отрендерен как элемент вне документа (off-document element), и для вставки в документ вам придётся самостоятельно использовать нативное DOM API.
  
  Метод возвращает сам инстанс, что позволяет вызывать дополнительные методы по цепочке.

- **Пример:**

  ``` js
  var MyComponent = Vue.extend({
    template: '<div>Hello!</div>'
  })

  // создать и примонировать в #app (заменит #app)
  new MyComponent().$mount('#app')

  // будет иметь тот же эффект что и запись выше:
  new MyComponent({ el: '#app' })

  // или, возможен рендеринг вне документа, с последующей вставкой:
  var component = new MyComponent().$mount()
  document.getElementById('app').appendChild(component.$el)
  ```

- **См. также:**
  - [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)
  - [Рендеринг на Сервере](/guide/ssr.html)

<h3 id="vm-forceUpdate">vm.$forceUpdate()</h3>

- **Использование:**

  Заставляет инстанс Vue произвести ререндеринг. Обратите внимание, что это действие не распространяется на все дочерние компоненты, а только на сам инстанс и дочерние компоненты со слотами контента.  

<h3 id="vm-nextTick">vm.$nextTick( callback )</h3>

- **Аргументы:**
  - `{Function} callback`

- **Использование:**

  Откладывает callback на следующую итерацию цикла обновления DOM. Используйте непосредственно после того как вносите изменения в данные, чтобы подождать обновления DOM. Совпадает с глобальным `Vue.nextTick`, за исключением автоматического связывания контекстной переменной `this` с вызывающим инстансом.

- **Пример:**

  ``` js
  new Vue({
    // ...
    methods: {
      // ...
      example: function () {
        // изменение данных
        this.message = 'changed'
        // DOM ещё не обновлён
        this.$nextTick(function () {
          // теперь DOM обновлён
          // `this` указывает на текущий инстанс
          this.doSomethingElse()
        })
      }
    }
  })
  ```

- **См. также:**
  - [Vue.nextTick](#Vue-nextTick)
  - [Очередь Асинхронных Обновлений](/guide/reactivity.html#Async-Update-Queue)

<h3 id="vm-destroy">vm.$destroy()</h3>

- **Использование:**
  
  Полностью уничтожает vm. Очищает связи с другими существующими vm, отвязывает директивы, выключает все слушатели событий.

  Вызывает хуки `beforeDestroy` и `destroyed`.
  
  <p class="tip">В нормальных вариантах использования вам не придётся вызывать этот метод самим. Предпочтительнее контроллировать жизненный цикл дочерних компонент в data-driven стиле, использую `v-if` и `v-for`.</p>

- **См. также:** [Диаграмма Жизненного Цикла](/guide/instance.html#Lifecycle-Diagram)

## Директивы

### v-text

- **Ожидает:** `string`

- **Подробности:**

  Обновляет `textContent` элемента. Если необходимо обновить часть `textContent`, используйте интерполяцию `{% raw %}{{ Mustache }}{% endraw %}`.

- **Пример:**

  ```html
  <span v-text="msg"></span>
  <!-- то же, что -->
  <span>{{msg}}</span>
  ```

- **См. также:** [Синтаксис Связывания Данных - интерполяции](/guide/syntax.html#Text)

### v-html

- **Ожидает:** `string`

- **Подробности:**
  
  Обновляет `innerHTML` элемента. **Обратите внимание, что содержимое вставляется как обычный HTML — то есть не компилируется как шаблон Vue**. Если вы обнаружите себя за попытками организации вложенных компонент при помощи `v-html`, попробуйте вместо этого применить компоненты.

  <p class="tip">Динамический рендеринг произвольного HTML-кода на сайте может быть очень опасным, так как легко приводит к [XSS атакам](https://en.wikipedia.org/wiki/Cross-site_scripting). Используйте `v-html` только на доверенном контенте, и **никогда** — на предоставляемом пользователями.</p>

- **Пример:**

  ```html
  <div v-html="html"></div>
  ```
- **См. также:** [Синтаксис Связывания Данных - интерполяции](/guide/syntax.html#Raw-HTML)

### v-if

- **Ожидает:** `any`

- **Использование:**
  
  В зависимости от истинности значения указанного выражения, рендерит (или нет) элемент. Элемент и содержащиеся в нём директивы / компоненты уничтожаются и заново создаются при переключениях. Для фиктивного элемента `<template>` в качестве результирующего условного блока используется внутреннее содержимое.

  Эта директива вызывает transitions при изменении состояния.

- **См. также:** [Условный Рендеринг - v-if](/guide/conditional.html)

### v-show

- **Ожидает:** `any`

- **Использование:**

  Переключает CSS-свойство `display` элемента, в зависимости от истинности значения указанного выражения.

  Эта директива вызывает transitions при изменении состояния.


- **См. также:** [Условный Рендеринг - v-show](/guide/conditional.html#v-show)

### v-else

- **Не ожидает какого-либо выражения**

- **Ограничение:** предыдущий элемент должен иметь директиву `v-if`.

- **Использование:**

  Определяет "блок else" для `v-if`.

  ```html
  <div v-if="Math.random() > 0.5">
    Сейчас меня видно
  </div>
  <div v-else>
    А сейчас — нет
  </div>
  ```

- **См. также:**
  - [Условный Рендеринг - v-else](/guide/conditional.html#v-else)

### v-for

- **Ожидает:** `Array | Object | number | string`

- **Использование:**

  Рендерит элемент или блок шаблона многократно, основываясь на указанных данных. Значение директивы должно следовать особому синтаксису ` alias in expression` чтобы использовать alias для доступа к элементу данной итерации:

  ``` html
  <div v-for="item in items">
    {{ item.text }}
  </div>
  ```

  Альтернативным образом, вы можете также указать алиас для индекса (или ключа, при использовании с Объектами):

  ``` html
  <div v-for="(item, index) in items"></div>
  <div v-for="(val, key) in object"></div>
  <div v-for="(val, key, index) in object"></div>
  ```
  
  По умолчанию `v-for` будет пытаться обновить элементы "на месте", не перемещая их. Для явного указания необходимости перемещения, используйте специальный атрибут `key`:

  ``` html
  <div v-for="item in items" :key="item.id">
    {{ item.text }}
  </div>
  ```

  Использование `v-for` подробно описано в нижеуказанной секции Руководства.

- **См. также:**
  - [Рендеринг Списков](/guide/list.html)
  - [key](/guide/list.html#key)

### v-on

- **Сокращение:** `@`

- **Ожидает:** `Function | Inline Statement`

- **Параметр:** `event (указание обязательно)`

- **Модификаторы:**
  - `.stop` - вызовет `event.stopPropagation()`.
  - `.prevent` - вызовет `event.preventDefault()`.
  - `.capture` - добавит слушатель в "capture mode".
  - `.self` - вызовет обработчик только в случае возникновения события непосредственно на этом элементе.
  - `.{keyCode | keyAlias}` - вызывает обработчик только при нажатии определённой клавиши.
  - `.native` - слушать нативное событие на корневом элементе компонента.

- **Использование:**
  
  Прикрепляет к элементу слушателя события. Тип события указывается в параметре. Выражение может быть как именем метода, так и inline-выражением, или вовсе отсутствовать, если указан модификатор(ы).
  
  При использовании на обычном элементе, слушает только **нативные события DOM**. При использовании на элементе пользовательского компонента, слушает также **пользовательские события**, эмитируемые этим дочерним компонентом.
  
  При слушании нативных событий DOM, метод получает нативное событие единственным аргументом. При использовании inline-выражений, выражение имеет доступ к специальному свойству `$event`: `v-on:click="handle('ok', $event)"`.

- **Пример:**

  ```html
  <!-- обработчик метода -->
  <button v-on:click="doThis"></button>

  <!-- inline-выражение -->
  <button v-on:click="doThat('hello', $event)"></button>

  <!-- сокращение -->
  <button @click="doThis"></button>

  <!-- stop propagation -->
  <button @click.stop="doThis"></button>

  <!-- prevent default -->
  <button @click.prevent="doThis"></button>

  <!-- prevent default без дополнительных действий -->
  <form @submit.prevent></form>

  <!-- цепочка из модификаторов -->
  <button @click.stop.prevent="doThis"></button>

  <!-- модификатор клавиши keyAlias -->
  <input @keyup.enter="onEnter">

  <!-- модификатор клавиши keyCode -->
  <input @keyup.13="onEnter">
  ```

  Слушание пользовательских события на дочернем элементе (обработчик вызывается, когда в дочерний элемент эмитирует "my-event"):

  ```html
  <my-component @my-event="handleThis"></my-component>

  <!-- inline-выражение -->
  <my-component @my-event="handleThis(123, $event)"></my-component>

  <!-- слушать нативное событие в компоненте -->
  <my-component @click.native="onClick"></my-component>
  ```

- **См. также:**
  - [Методы и Обработка Событий](/guide/events.html)
  - [Компоненты - Пользовательские События](/guide/components.html#Custom-Events)

### v-bind

- **Сокращение:** `:`

- **Ожидает:** `any (with argument) | Object (without argument)`

- **Параметр:** `attrOrProp (optional)`

- **Модификаторы:**
  - `.prop` - Used for binding DOM attributes.

- **Использование:**

  Dynamically bind one or more attributes, or a component prop to an expression.

  When used to bind the `class` or `style` attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.

  When used for prop binding, the prop must be properly declared in the child component.

  When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode `class` and `style` does not support Array or Objects.

- **Пример:**

  ```html
  <!-- bind an attribute -->
  <img v-bind:src="imageSrc">

  <!-- shorthand -->
  <img :src="imageSrc">

  <!-- class binding -->
  <div :class="{ red: isRed }"></div>
  <div :class="[classA, classB]"></div>
  <div :class="[classA, { classB: isB, classC: isC }]">

  <!-- style binding -->
  <div :style="{ fontSize: size + 'px' }"></div>
  <div :style="[styleObjectA, styleObjectB]"></div>

  <!-- binding an object of attributes -->
  <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

  <!-- DOM attribute binding with prop modifier -->
  <div v-bind:text-content.prop="text"></div>

  <!-- prop binding. "prop" must be declared in my-component. -->
  <my-component :prop="someThing"></my-component>

  <!-- XLink -->
  <svg><a :xlink:special="foo"></a></svg>
  ```

- **См. также:**
  - [Class and Style Bindings](/guide/class-and-style.html)
  - [Компоненты - Component Props](/guide/components.html#Props)

### v-model

- **Ожидает:** varies based on value of form inputs element or output of components

- **Limited to:**
  - `<input>`
  - `<select>`
  - `<textarea>`
  - components

- **Модификаторы:**
  - [`.lazy`](/guide/forms.html#lazy) - listen to `change` events instead of `input`
  - [`.number`](/guide/forms.html#number) - cast input string to numbers
  - [`.trim`](/guild/forms.html#trim) - trim input

- **Использование:**

  Create a two-way binding on a form input element or a component. For detailed usage, see guide section linked below.

- **См. также:**
  - [Form Input Bindings](/guide/forms.html)
  - [Компоненты - Form Input Компоненты using Пользовательские События](/guide/components.html#Form-Input-Компоненты-using-Custom-Events)

### v-pre

- **Does not expect expression**

- **Usage**

  Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.

- **Пример:**

  ```html
  <span v-pre>{{ this will not be compiled }}</span>
   ```

### v-cloak

- **Does not expect expression**

- **Использование:**

  This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as `[v-cloak] { display: none }`, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.

- **Пример:**

  ```css
  [v-cloak] {
    display: none;
  }
  ```

  ```html
  <div v-cloak>
    {{ message }}
  </div>
  ```

  The `<div>` will not be visible until the compilation is done.

### v-once

- **Does not expect expression**

- **Подробности:**

  Render the element and component **once** only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.

  ```html
  <!-- single element -->
  <span v-once>This will never change: {{msg}}</span>
  <!-- the element have children -->
  <div v-once>
    <h1>comment</h1>
    <p>{{msg}}</p>
  </div>
  <!-- component -->
  <my-component v-once :comment="msg"></my-component>
  <!-- v-for directive -->
  <ul>
    <li v-for="i in list" v-once>{{i}}</li>
  </ul>
  ```

- **См. также:**
  - [Синтаксис Связывания Данных - интерполяции](/guide/syntax.html#Text)
  - [Компоненты - Cheap Static Компоненты with v-once](/guide/components.html#Cheap-Static-Компоненты-with-v-once)

## Special Attributes

### key

- **Ожидает:** `string`

  The `key` special attribute is primarily used as a hint for Vue's virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.

  Children of the same common parent must have **unique keys**. Duplicate keys will cause render errors.

  The most common use case is combined with `v-for`:

  ``` html
  <ul>
    <li v-for="item in items" :key="item.id">...</li>
  </ul>
  ```

  It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:

  - Properly trigger lifecycle hooks of a component
  - Trigger transitions

  For example:

  ``` html
  <transition>
    <span :key="text">{{ text }}</span>
  </transition>
  ```

  When `text` changes, the `<span>` will always be replaced instead of patched, so a transition will be triggered.

### ref

- **Ожидает:** `string`

  `ref` is used to register a reference to an element or a child component. The reference will be registered under the parent component's `$refs` object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:

  ``` html
  <!-- vm.$refs.p will the DOM node -->
  <p ref="p">hello</p>

  <!-- vm.$refs.child will be the child comp instance -->
  <child-comp ref="child"></child-comp>
  ```

  When used on elements/components with `v-for`, the registered reference will be an Array containing DOM nodes or component instances.

  An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don't exist yet! `$refs` is also non-reactive, therefore you should not attempt to use it in templates for data-binding.

- **См. также:** [Ссылки Дочерних Компонентов](/guide/components.html#Child-Component-Refs)

### slot

- **Ожидает:** `string`

  Used on content inserted into child components to indicate which named slot the content belongs to.

  For detailed usage, see the guide section linked below.

- **См. также:** [Named Slots](/guide/components.html#Named-Slots)

## Built-In Компоненты

### component

- **Props:**
  - `is` - string | ComponentDefinition | ComponentConstructor
  - `inline-template` - boolean

- **Использование:**

  A "meta component" for rendering dynamic components. The actual component to render is determined by the `is` prop:

  ```html
  <!-- a dynamic component controlled by -->
  <!-- the `componentId` property on the vm -->
  <component :is="componentId"></component>

  <!-- can also render registered component or component passed as prop -->
  <component :is="$options.components.child"></component>
  ```

- **См. также:** [Динамические Компоненты](/guide/components.html#Dynamic-Компоненты)

### transition

- **Props:**
  - `name` - string, Used to automatically generate transition CSS class names. e.g. `name: 'fade'` will auto expand to `.fade-enter`, `.fade-enter-active`, etc. Defaults to `"v"`.
  - `appear` - boolean, Whether to apply transition on initial render. Defaults to `false`.
  - `css` - boolean, Whether to apply CSS transition classes. Defaults to `true`. If set to `false`, will only trigger JavaScript hooks registered via component events.
  - `type` - string, Specify the type of transition events to wait for to determine transition end timing. Available values are `"transition"` and `"animation"`. By default, it will automatically detect the type that has a longer duration.
  - `mode` - string, Controls the timing sequence of leaving/entering transitions. Available modes are `"out-in"` and `"in-out"`; defaults to simultaneous.
  - `enter-class` - string
  - `leave-class` - string
  - `enter-active-class` - string
  - `leave-active-class` - string
  - `appear-class` - string
  - `appear-active-class` - string

- **Events:**
  - `before-enter`
  - `enter`
  - `after-enter`
  - `before-leave`
  - `leave`
  - `after-leave`
  - `before-appear`
  - `appear`
  - `after-appear`

- **Использование:**

  `<transition>` serve as transition effects for **single** element/component. The `<transition>` does not render an extra DOM element, nor does it show up in the inspected component hierarchy. It simply applies the transition behavior to the wrapped content inside.

  ```html
  <!-- simple element -->
  <transition>
    <div v-if="ok">toggled content</div>
  </transition>

  <!-- dynamic component -->
  <transition name="fade" mode="out-in" appear>
    <component :is="view"></component>
  </transition>

  <!-- event hooking -->
  <div id="transition-demo">
    <transition @after-enter="transitionComplete">
      <div v-show="ok">toggled content</div>
    </transition>
  </div>
  ```

  ``` js
  new Vue({
    ...
    methods: {
      transitionComplete: function (el) {
        // for passed 'el' that DOM element as the argument, something ...
      }
    }
    ...
  }).$mount('#transition-demo')
  ```

- **См. также:** [Transitions: Entering, Leaving, and Lists](/guide/transitions.html)

### transition-group

- **Props:**
  - `tag` - string, defaults to `span`.
  - `move-class` - overwrite CSS class applied during moving transition.
  - exposes the same props as `<transition>` except `mode`.

- **Events:**
  - exposes the same events as `<transition>`.

- **Использование:**

  `<transition-group>` serve as transition effects for **multiple** elements/components. The `<transition-group>` renders a real DOM element. By default it renders a `<span>`, and you can configure what element is should render via the `tag` attribute.

  Note every child in a `<transition-group>` must be **uniquely keyed** for the animations to work properly.

  `<transition-group>` supports moving transitions via CSS transform. When a child's position on screen has changed after an updated, it will get applied a moving CSS class (auto generated from the `name` attribute or configured with the `move-class` attribute). If the CSS `transform` property is "transition-able" when the moving class is applied, the element will be smoothly animated to its destination using the [FLIP technique](https://aerotwist.com/blog/flip-your-animations/).

  ```html
  <transition-group tag="ul" name="slide">
    <li v-for="item in items" :key="item.id">
      {{ item.text }}
    </li>
  </transition-group>
  ```

- **См. также:** [Transitions: Entering, Leaving, and Lists](/guide/transitions.html)

### keep-alive

- **Использование:**

  When wrapped around a dynamic component, `<keep-alive>` caches the inactive component instances without destroying them. Similar to `<transition>`, `<keep-alive>` is an abstract component: it doesn't render a DOM element itself, and doesn't show up in the component parent chain.

  When a component is toggled inside `<keep-alive>`, its `activated` and `deactivated` lifecycle hooks will be invoked accordingly.

  Primarily used with preserve component state or avoid re-rendering.

  ```html
  <!-- basic -->
  <keep-alive>
    <component :is="view"></component>
  </keep-alive>

  <!-- multiple conditional children -->
  <keep-alive>
    <comp-a v-if="a > 1"></comp-a>
    <comp-b v-else></comp-b>
  </keep-alive>

  <!-- used together with <transition> -->
  <transition>
    <keep-alive>
      <component :is="view"></component>
    </keep-alive>
  </transition>
  ```

  <p class="tip">`<keep-alive>` does not work with functional components because they do not have instances to be cached.</p>

- **См. также:** [Динамические Компоненты - keep-alive](/guide/components.html#keep-alive)

### slot

- **Props:**
  - `name` - string, Used for named slot.

- **Использование:**

  `<slot>` serve as content distribution outlets in component templates. `<slot>` itself will be replaced.

  For detailed usage, see the guide section linked below.

- **См. также:** [Content Distribution with Slots](/guide/components.html#Content-Distribution-with-Slots)

## VNode Interface

- Please refer to the [VNode class declaration](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).

## Server-Side Rendering

- Please refer to the [vue-server-renderer package documentation](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).
