---
title: Сравнение с Другими Фреймворками
type: guide
order: 28
---

Определённо, этот раздел руководства — самый трудный для написания, но он очень важен. Вероятно, вы уже решаете некоторые задачи, используя тот или иной фреймворк или библиотеку. И сюда вас привело желание узнать, не позволит ли Vue решать стоящие перед вами задачи эффективнее и проще. На этот вопрос мы и надеемся дать ответ в этом документе.

Мы очень постараемся не быть предвзятыми. Будучи членами основной команды разработки Vue, мы, разумеется, сами его очень любим. На наш взгляд, с некоторыми задачами он справляется лучше, чем какой-либо иной существующий инструмент. Если бы мы не верили в это, мы бы наверное и не работали над этим проектом, верно? И тем не менее, нам бы хотелось быть предельно честными и точными в оценках. В тех случаях, когда альтернативные библиотеки имеют существенные преимущества, как например обширнейшая экосистема альтернативных рендереров React'а или поддержка браузеров вплоть до IE6 Knockout'ом, мы постараемся о не забыть о них упомянуть.

Кроме того, мы бы очень оценили **вашу** помощь в деле поддержания актуальности этого документа, ибо мир JavaScript развивается стремительно! Если вы заметите какую-либо неточность или что-то, что не выглядит правильным, пожалуйста — дайте нам знать, [открыв issue](https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide).

## React

React и Vue во многом похожи. Они оба:

- используют virtual DOM
- предоставляют реактивность и компонентную структуру
- фокусируются на корневой библиотеке, вынося прочие вопросы, такие как роутинга или управления глобальным состоянием приложения в дополнительные библиотеки

Из-за столь похожих ниш, мы уделили сравнению этих фреймворков больше всего времени. Нашей целью было не только удостовериться в технической точности, но также и сохранить баланс. Мы указываем, где React превосходит Vue, например — в богатстве экосистемы и изобилии доступных пользовательских рендереров.

Помощь React-сообщества [была неоценима](https://github.com/vuejs/vuejs.org/issues/364) в деле достижения этого баланса. Особо хотелось бы поблагодарить Даниила Абрамова из команды разработки React. Он был крайне щедр на время и опыт, помогая нам довести этот документ до состояния, когда обе стороны [остались довольны](https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244575740) финальным результатом.

Учитывая вышесказанное, мы надеемся что у вас не возникнет сомнений в честности нижепредставленного сравнения, в котором мы рассмотрим различия между этими библиотеками.

### Сравнение Быстродействия

В каждом из реалистичных сценариев, в котором мы проводили тесты, Vue существенно превзошёл React по быстродействию. Если ваши брови сейчас поднялись, читайте дальше. Мы расскажем, почему (и даже покажем бенчмарк, разработанный вместе с командой React).

#### Быстродействие при Рендеринге

При рендеренге UI, манипулирование DOM — зачастую самая дорогая операция. К сожалению, ни одна библиотека не может сделать эти низкоуровневые операции быстрее. Лучшее, что мы можем сделать — это:

1. Минимизировать необходимое количество изменений в DOM. Как React, так и Vue используют virtual DOM для этих целей — и примерно с равным успехом.
2. Добавить как можно меньше дополнительных операций поверх манипуляций с DOM. Здесь Vue и React отличаются.

В React, условно говоря, дополнительная трудоёмкость рендеринга элемента равна 1, а для компонента — 2. Для Vue эти цифры будут ближе к 0.1 и 4 соответственно, из-за архитектуры нашей системы реактивности.

Это значит, что в типичных приложениях, где элементов DOM куда больше, чем компонентов, Vue будет существенно обгонять React. В экстремальных же случаях, таких как использование 1 компонента для каждого HTML-элемента, Vue обычно будет медленнее. Но это ещё не всё.

И Vue, и React позволяют использовать функциональные компоненты, не имеющие ни собственного состояния, ни инстанса — и потому требующие меньших вычислительных затрат. При использовании таких компонентов в критичных по быстродействию ситуациях, Vue вновь оказывается быстрее. Для демонстрации этого, мы создали простой [бенчмарк](https://github.com/chrisvfritz/vue-render-performance-comparisons), который просто рендерит 10,000 элементов списка 100 раз. Мы призываем вас попробовать запустить его самим. Результаты отличаются в зависимости от используемого железа, браузера — и даже просто от запуска к запуску, в силу природы JavaScript-движков.

Впрочем, если вам лень этим заниматься — вот цифры, полученные при запуска бенчмарка в Chrome 52 на MacBook Air 2014. Во избежание соблазнов интерпретации, в таблицу были включены лучшие из результатов, отобранные из 20 запусков теста:

{% raw %}
<table class="benchmark-table">
  <thead>
    <tr>
      <th></th>
      <th>Vue</th>
      <th>React</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Fastest</th>
      <td>23ms</td>
      <td>63ms</td>
    </tr>
    <tr>
      <th>Median</th>
      <td>42ms</td>
      <td>81ms</td>
    </tr>
    <tr>
      <th>Average</th>
      <td>51ms</td>
      <td>94ms</td>
    </tr>
    <tr>
      <th>95th Perc.</th>
      <td>73ms</td>
      <td>164ms</td>
    </tr>
    <tr>
      <th>Slowest</th>
      <td>343ms</td>
      <td>453ms</td>
    </tr>
    </tr>
  </tbody>
</table>
{% endraw %}

#### Производительность Обновлений

В React для достижения полной оптимизации ререндеринга необходимо написать `shouldComponentUpdate` для каждого компонента, а также использовать иммутабельные структуры данных. Во Vue же, зависимости компонентов отслеживаются автоматически, поэтому они обновляются только при изменении одной из зависимостей. Единственная дополнительная оптимизация, иногда оказывающаяся полезной — это добавление ключа `key` в качестве аттрибута элементов длинных списков.

Это значит, что обновления в приложениях без специально проведённой оптимизации Vue будет показывать значительно лучшую производительность. В действительности, из-за улучшенной производительности Vue, даже полностью оптимизированные React-приложения обычно оказываются медленнее, чем приложения Vue "из коробки".

#### Производительность при Разработке

Разумеется, производительность в production — наиболее важна, и её-то мы до сих пор и обсуждали. Но и при разработке быстродействие имеет не малое значение. Хорошие новости — и Vue, и React в режиме разработки остаются довольно шустрыми для большей части приложений.

Однако, если вы занимаетесь прототипированием высокопроизводительных визуализаций данных или анимаций, вам может быть полезным знать, что в тех сценариях где Vue не мог отрендерить больше 10 кадров в секунду в режиме разработки, наблюдаемая производительность React'а находилась на уровне около 1 кадра в секунду.

Причина этой разницы — во множестве тяжёлых инвариантных проверок, помогающих снабдить разработчиков прекрасными предупреждениями и сообщениями об ошибках. Мы согласны, что эти сообщения важны — но во Vue и при их имплементации постарались не забыть о производительности.

### HTML & CSS

В React, всё — это JavaScript. Пока не копнёшь глубже — звучит это замечательно. Неприятным свойством реальности, однако, является то, что изобретение заново HTML и CSS внутри JavaScript может принести немало страдания. Во Vue мы, напротив, постарались задействовать существующие web-технологии. Чтобы показать вам, что из этого вышло, мы рассмотрим несколько примеров.

#### JSX vs Шаблоны

In React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within Javascript. Here's an example, [vetted by the React community](https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244582684):

В React, все компоненты описывают свой UI посредством render-функций, используя JSX — декларативные XML-подобный синтаксис, работающий внутри JavaScript. Вот пример, [проверенный сообществом React](https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244582684):

``` jsx
render () {
  let { items } = this.props

  let children
  if (items.length > 0) {
    children = (
      <ul>
        {items.map(item =>
          <li key={item.id}>{item.name}</li>
        )}
      </ul>
    )
  } else {
    children = <p>No items found.</p>
  }

  return (
    <div className='list-container'>
      {children}
    </div>
  )
}
```

Render-функции, использующие JSX, имеют определённые преимущества:

- Возможность использовать все алгоритмические возможности JavaScript при создании представления
- Поддержка инструментария (линтинг, проверки типов, автодополнение в редакторах) для JSX зачастую более развито, чем то, что доступно сейчас для шаблонов Vue.

Во Vue, у нас тоже есть [Render-Функции](render-function.html), и даже [поддежка JSX](render-function.html#JSX), так как иногда эти возможности нужны. Однако, для большей части компонентов render-функции использовать не рекомендуется.

В качестве более простой альтернативы мы предлагаем использовать шаблоны:

``` html
<template>
  <div class="list-container">
    <ul v-if="items.length">
      <li v-for="item in items">
        {{ item.name }}
      </li>
    </ul>
    <p v-else>Ничего не найдено.</p>
  </div>
</template>
```

Вот некоторые преимущества этого подхода:

- При написании шаблона требуется принимать значительно меньшее количество решений по части деталей и стиля имплементации
- Шаблон всегда остаётся декларативным
- Любой валидный HTML — это автоматичеки валидный шаблон
- Читать шаблоны проще, они больше похожи на обыкновенный английский (напр. for each item in items)
- Для улучшения читабельности кода не требуется использования продвинутых версий JavaScript

Проще становится не только пишущим шаблон разработчикам, но и дизайнерам и менее опытным программистам, читающим и правящим его.

Но это ещё не всё. Используя HTML вместо попытки его изобретения заново, Vue позволяет использовать в шаблонах препроцессоры, такие как Pug (ранее известный как Jade).

В экосистеме React существует [проект](https://wix.github.io/react-templates/), позволяющий использовать шаблоны, но с некоторыми неудобствами:

- Возможностей значительно меньше, чем в шаблонах Vue
- Требуется отделение HTML от файлов компонентов
- Из-за того, что этот проект является сторонним, а не официально поддерживаемым, неизвестно, будет ли он сопровождаться и поддерживаться в актуальном состоянии при дальнейшем развитии ядра React в будущем

#### Модульный (Компонентный) CSS

Если только вы не разделяете компоненты на несколько файлов (например, используя [CSS-модули](https://github.com/gajus/react-css-modules)), ограничение области видимости CSS в React идёт в комплекте с некоторыми неприятностями. Самый базовый CSS прекрасно работает "из коробки", чего не скажешь о более сложных вещах, вроде hover-эффектов, media queries и псевдоселекторов: все они либо тащат за собой зависимости, переизобретающие уже существующие возможности CSS - либо и вовсе не работают.

Vue же позволяет напрямую использовать CSS в [однофайловых компонентах](single-file-components.html):

``` html
<style scoped>
  @media (min-width: 250px) {
    .list-container:hover {
      background: orange;
    }
  }
</style>
```

Опциональный аттрибут `scoped` автоматически ограничивает область видимости CSS текущим компонентом, добавляя элементам уникальные аттрибуты (такие как `data-v-1`), и компилируя `.list-container:hover` во что-нибудь вроде `.list-container[data-v-1]:hover`.

Наконец, как и с HTML, у вас есть возможность использования любых препроцессоров (или постпроцессоров) на ваш вкус. Это позволяет применять централизованные операции, такие как например управление цветами, на этапе сборки, не импортируя специализированных JavaScript-библиотек, увеличивающих как размер результирующей сборки, так и сложность вашего приложения.

### Масштабирование

#### Масштабирование Вверх

Для крупных приложений, как Vue так и React предоставляют надёжные решения для роутинга. Сообщество React также породило весьма инновационные решения в области управления состоянием приложения (т.е. Flux/Redux). Эти подходы, и [даже сам Redux](https://github.com/egoist/revue) легко интегрируются в приложения на Vue. В действительности, Vue идёт на шаг дальше с [Vuex](https://github.com/vuejs/vuex) — вдохновлённым Elm решением для управления состоянием приложения, глубоко интегрирующимся с Vue, что, на наш взгляд, изрядно облегчает жизнь разработчикам.

В качестве ещё одно важного различия между React и Vue можно упомянуть тот факт, что все дополнительные библиотеки Vue для управления состоянием и роутинга (среди [прочих задач](https://github.com/vuejs)) официально поддерживаются и поддерживаются в актуальном соответствии с ядром библиотеки. React, напротив, предпочитает оставить эти вопросы на откуп сообществу, тем самым создавая более фрагментированную экосистему. Впрочем, в силу популярности, экосистема React значительно обширнее, чем у Vue.

Наконец, Vue предоставляет [инструменты командной строки для генерации проектов](https://github.com/vuejs/vue-cli), до смешного упрощающие создание новых проектов с использованием подходящей системы сборки, включая [Webpack](https://github.com/vuejs-templates/webpack), [Browserify](https://github.com/vuejs-templates/browserify), или даже [вовсе без таковой](https://github.com/vuejs-templates/simple). В сообществе React также существуют наработки в этом направлении — например, [create-react-app](https://github.com/facebookincubator/create-react-app), но на данный момент функционал этого решения имеет ряд ограничений:

- Нет возможности конфигурации проекта в процессе генерации. Vue позволяте Yeoman-подобную настройку шаблонов.
- Существует единственный шаблон для одностраничного приложения, в то время как Vue позволяет выбрать подходящий шаблон из довольно широкого их многообразия.
- Нет возможности создавать проекты из пользовательских шаблонов, что может быть особенно полезно для enterprise-окружений с установившимися ранее соглашениями.

Важно заметить, что многие из этих ограничений — следствия сознательно принятых командой create-react-app решений, и в них есть и свои плюсы. Например, коль скоро ваш проект не требует многого, и не имеет необходимости пользовательской настройки процесса сборки, оную можно будет обновлять как зависимость. Прочитать больше [об этом подходе можно здесь](https://github.com/facebookincubator/create-react-app#philosophy).

#### Масштабирование Вниз

React известен своей крутой кривой изучения. До того момента, когда новичок сможет что-то написать, ему придётся узнать о JSX, а вероятно — и о ES2015+, поскольку многие примеры используют синтаксис классов. Кроме того придётся разобраться с системами сборки, поскольку хотя технически и существует возможность использовать Babel самостоятельно для live-компиляции кода, для production это в любом случае не рекомендуется.

Vue масштабируется вверх ничуть не хуже (если не лучше), чем React, и в то же время его можно масштабировать вниз вплоть до варианта использования вместе с jQuery. Именно так — в простейшем случае достаточно добавить тег скрипта на HMTL-страницу.

``` html
<script src="https://unpkg.com/vue/dist/vue.js"></script>
```

Начиная с этого момента можно писать код на Vue, и даже собрать production-версию, не мучаясь угрызениями совести и волнениями насчёт производительности.

Поскольку знания JSX, ES2015 и систем сборки не требуется для начала работы со Vue, в среднем у новых разработчиков уходит не больше дня на чтение [руководства](/guide), позволяющего узнать достаточно для построения нетривиальных приложений.

### Нативный Рендеринг

ReactNative позволяет писать нативные приложения для iOS и Android, используя ту же самую модель компонент React'а. Это — прекрасно, так как позволяет разработчикам применить знание одного и того же фреймворка для различных платформ. В этой области, Vue официально поддерживает проект [Weex](https://alibaba.github.io/weex/), кросс-платформенный UI-фреймворк, разрабатываемый Alibaba Group и использующий Vue как JavaScript-фреймворк времени выполнения. Это значит, что с Weex вы можете использовать тот же синтаксис Vue для создания не только компонентов для отображения в браузерах, но и для нативных элементов iOS и Android!

На данный момент, Weex всё ещё находится в активной фазе разработки, и ещё не столь матёр и проверен опытом, как ReactNative, но его разработка мотивируется реальными требованиями крупнейшего бизнеса электронной коммерции в мире. Команда разработки Vue также активно взаимодействует с разработчиками Weex, гарантируя приятный опыт для Vue-разработчиков.

### Сравнение с MobX

MobX стал довольно популярным в сообществе React. Он использует почти идентичную Vue систему реактивности. В некотором смысле, связку React + MobX можно считать несколько более многословным Vue, так что если вы используете её и она вам нравится, возможно переход на Vue станет следующим логичным шагом.

## Angular 1

Некоторые части синтаксиса Vue выглядят очень похоже на синтаксис Angular (напр. `v-if` vs `ng-if`). Причина в том, что многие идеи в основе Angular были верными, и вдохновили Vue на ранних этапах разработки. Впрочем, в Angular было немало и боли, и в этих вопросах мы при разработке Vue постарались добиться значительных улучшений.

### Сложность

Vue значительно проще Angular 1, как в смысле API, так и в смысле архитектуры. Получение достаточных знаний для написания нетривиальных приложений обычно происходит менее чем за день, чего нельзя сказать об Angular 1. 

### Гибкость и Модульность

Angular 1 имеет жёсткое мнение насчёт структуры вашего приложения, в то время как Vue проявляет гибкость и является более модульным решением. Хотя это и делает Vue пригодным для большего разнообразия проектов, мы понимаем и то, что зачастую полезно, когда решения уже приняты за тебя — и можно сразу начать программировать.

По этой причине мы предоставляем [Webpack template](https://github.com/vuejs-templates/webpack), позволяющий начать работу в течении нескольких минут, в то же время предоставляя доступ к таким продвинутым возможностям, как перезагрузка модулей, линтинг, экстракция CSS и прочим.

### Связывание данных

Angular 1 использует двунаправленное связывание данных между областями видимости, в то время как Vue концентрируется на однонаправленном потоке данных между компонентами. Это позволяет облегчить размышление о потоке данных в нетривиальных приложениях.

### Директивы vs Компоненты

Vue чётче разделяет директивы и компоненты. Директивы предназначены только для сокрытия низкоуровневых манипуляций с DOM, в то время как компоненты являют собой автономные объекты, со своей собственной логикой данных и представления. В Angular эти два концепта в значительной мере смешаны.

### Производительность

Vue имеет лучшую производительность. Кроме того, из-за отсутствия dirty-checking оптимизация Vue-приложений намного, намного проще. Angular 1 замедляется при увеличении количества наблюдателей, поскольку каждый раз при изменении чего-либо в области видимости все эти наблюдатели должны быть перезапущены. Кроме того, цикл может повториться несколько раз перед стабилизацией, поскольку реакция наблюдателей может спровоцировать следующее обновление. Пользователям Angular нередко приходится прибегать к весьма эзотерическим техникам для обхода этих трудностей. В некоторых случаях в случае избытка наблюдателей оптимизация и вовсе становится невозможной.

Vue не подвержен всем этим проблемам по причине использования прозрачного механизма учёта зависимостей с асинхронной очередью — все изменения рассматриваются независимо, кроме случаев явного указания наличия их связи.

Любопытно, что этот подход делает Vue во многом похожим на Angular 2.

## Angular 2

Мы выделяем отдельную секцию для Angular 2, поскольку по сути он является совершенно новым фреймворком. Например, теперь он содержит первоклассную компонентную систему; многие детали имплементации были полностью переписаны, а API очень существенно изменился.

### TypeScript

В то время как Angular мог быть использован для небольших приложений, Angular 2 сместил акцент в область крупных enterprise-приложений. Отчасти по этой причине, он почти требует использования TypeScript, что может быть весьма полезно для разработчиков, предпочитающих привычную по языкам вроде Java и C# безопасную типизацию.

Vue тоже хорошо подходит для [enterprise-окружений](https://github.com/vuejs/awesome-vue#enterprise-usage) и может использоваться в том числе и с TypeScript при помощи наших [официальных типов](https://github.com/vuejs/vue/tree/dev/types) и [пользовательских декораторов](https://github.com/itsFrank/vue-typescript), что, впрочем, в нашем случае — полностью опционально.

### Размер и Быстродействие

В смысле производительности, оба фреймворка весьма шустры, и пока нет достаточных данных из реального мира чтобы вынести вердикт. Но если вы хотите цифр, Vue 2.0 похоже что обгоняет Angular 2, если верить этому [стороннему исследованию производительности](http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html).

Что касается размера, то хотя Angular 2 с его оффлайн-компиляцией и возможностями удаления неиспользуемого функционала может существенно уменьшить свой вес, полнофункциональная сборка Vue 2.0, включающая даже компилятор шаблонов (23kb) всё ещё оказывается значительно меньше предельно облегчённой версии Angular 2 (50kb). Заметьте и то, что уменьшение размера Angular 2 достигается путём выбрасывания неиспользуемого функционала. Когда этот функционал понадобится — размер сборки фреймворка может снова возрасти.

### Гибкость

Vue значительно менее упрям, чем Angular 2, и поддерживает множество различных систем сборок, не ограничивая разработчиков в том, какую структуру использовать для приложения. Многим программистам эта свобода нравится, хотя есть и те, кто предпочитают иметь Один Правильный Способ построения приложения.

### Кривая Обучения

Всё что необходимо для начала работы с Vue — это знакомство с HTML и обыкновенным (ES5) JavaScript'ом. С этими базовыми навыками вы уже можете начать строить нетривиальные приложения после менее чем однодневного прочтения [руководства](/guide).

Кривая обучения Angular 2 — куда круче. Даже без TypeScript, их [Руководство по Быстрому Старту](https://angular.io/docs/js/latest/quickstart.html) начинает с приложения, использующего ES2015 JavaScript и NPM с 18 зависимостями, 4 файлами и более чем 3,000 слов объяснений — просто для "Hello World". Не будет преувеличением, если мы скажем что [Hello World в исполнении Vue](index.html#Hello-World) — немного попроще. Возможно по этой причине мы даже не посвящаем ему отдельной страницы в руководстве.

## Ember

Ember — это полнофункциональный фреймворк, изначально созданный "имеющим и отстаивающим своё мнение". Он содержит множество соглашений и конвенций, и когда вы с ними освоитесь — он может сделать вас весьма продуктивными. Однако, это означает ещё и высокую и крутую кривую обучения, не говоря о страдающей гибкости. Выбор между жёстко структурированным фреймворком и библиотекой со слабосвязанными инструментами, работающими вместе — это всегда компромисс. Последняя даёт больше свободы, но и требует принятия большего количества архитектурных решений.

Учитывая вышесказанное, вероятно лучше сравнивать ядро Vue и слои [шаблонизации](https://guides.emberjs.com/v2.7.0/templates/handlebars-basics/) и [объектной модели](https://guides.emberjs.com/v2.7.0/object-model/) в Ember:

- Vue предлагает ненавязчиваю реактивность для простых JavaScript-объектов и полностью автоматические вычисляемые свойства. В Ember от вас ожидается заворачивание всего в Объекты Ember и ручное указание зависимостей для вычисляемых свойств.

- Синтаксис шаблонов Vue позволяет использовать все возможности выражений JavaScript, в то время как возможности выражений Handlebars и синтаксис хелперов намеренно ограничены.

- В том что касается производительности, Vue существенно выигрывает, даже с учётом последнего обновления Glimmer engine в Ember 2.0. Vue автоматически объединяет операции обновления, в то время как в Ember требуется ручное управление циклом выполнения в ситуациях, где производительность критична.

## Knockout

Knockout был пионером MVVM-подхода и отслеживания изменений в данных. Его система реактивности очень похожа на используемую Vue. Список [поддерживаемых браузеров](http://knockoutjs.com/documentation/browser-support.html) — впечатляет, особенно с учётом всех немалых возможностей фреймворка, доступных даже в IE6! Vue, напротив, не поддерживает браузеры старше IE9.

Со временем, однако, разработка Knockout замедлилась и он начал немного показывать возрастные признаки. Например, компонентной системе недостаёт полного набора хуков жизненного цикла, а интерфейс передачи дочерних компонентов, хотя это и очень распространённый случай, выглядит не очень хорошо по сравнению со [слотами Vue](components.html#Content-Distribution-with-Slots)

Кроме того, похоже что существует разница в философских подходах к API, которая, если вам интересно, может быть продемонстрирована различиями при создании [простого списка todo](https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89). Конечно же, это — субъективный вопрос, но многим API Vue кажется проще и лучше структурированным.

## Polymer

Polymer is yet another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue's components can be loosely compared to Polymer's custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don't support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9.

In Polymer 1.0, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible.

Polymer custom elements are authored in HTML files, which limits you to plain JavaScript/CSS (and language features supported by today's browsers). In comparison, Vue's single file components allows you to easily use ES2015+ and any CSS preprocessors you want.

When deploying to production, Polymer recommends loading everything on-the-fly with HTML Imports, which assumes browsers implementing the spec, and HTTP/2 support on both server and client. This may or may not be feasible depending on your target audience and deployment environment. In cases where this is not desirable, you will have to use a special tool called Vulcanizer to bundle your Polymer elements. On this front, Vue can combine its async component feature with Webpack's code-splitting feature to easily split out parts of the application bundle to be lazy-loaded. This ensures compatibility with older browsers while retaining great app loading performance.

It is also totally feasible to offer deeper integration between Vue with Web Component specs such as Custom Elements and Shadow DOM style encapsulation - however at this moment we are still waiting for the specs to mature and be widely implemented in all mainstream browsers before making any serious commitments.

## Riot

Riot 2.0 provides a similar component-based development model (which is called a "tag" in Riot), with a minimal and beautifully designed API. Riot and Vue probably share a lot in design philosophies. However, despite being a bit heavier than Riot, Vue does offer some significant advantages:

- True conditional rendering. Riot renders all if branches and simply shows/hides them.
- A far more powerful router. Riot’s routing API is extremely minimal.
- More mature tooling support. Vue provides official support for [Webpack](https://github.com/vuejs/vue-loader), [Browserify](https://github.com/vuejs/vueify), and [SystemJS](https://github.com/vuejs/systemjs-plugin-vue), while Riot relies on community support for build system integration.
- [Transition effect system](transitions.html). Riot has none.
- Better performance. [Despite advertising](https://github.com/vuejs/vuejs.org/issues/346) use of a virtual DOM, Riot in fact uses dirty checking and thus suffers from the same performance issues as Angular 1.
